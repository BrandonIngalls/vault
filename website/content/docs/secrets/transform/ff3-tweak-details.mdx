# FF3-1 Tweak Usage Documentation

## Introduction 

The Vault Transform Secrets Engine uses the FF3-1 algorithm for FPE 
(format preserving encryption) transformations. The key benefit of format
preserving encryption schemes is that it allows for the secure encryption 
of plaintexts over small domain spaces [1]. However, this comes with 
the introduction of a parameter called the tweak, which is supplied to the 
FF3-1 algorithm. Up until recently, the formal definitions of security in FPE 
schemes have assumed that an attacker only has access to one tweak when probing 
the codebook for a particular key. However, following the work of Bellare, this 
notion was changed to assume that an attacker could control multiple tweaks when 
generating a codebook and trying to create a nontrivial distinguisher for FF3-1. 

This page will give a few details of the FF3-1 algorithm, along with some
best practices when using tweaks.

## FF3-1 Tweak Usage

FF3-1 is a tweakable encryption scheme that was created to solve the problem of
encrypting on small domains. Tweaks were introduced to synthetically increase the
domain space. With the introduction of tweaks, an attacker must now have the
correct encryption of the plaintext and the correct tweak in order to backtrack 
via a codebook from an encryption to a plaintext. 

However, this backfires when the number of tweaks used in FF3-1 setups
is too small or is chosen on a restricted domain, or when it is user-generated and 
access control on encrypting is too broad. In the former case, a codebook can still
be easily created if the tweaks are known (since tweak values are not necessarily
secret [3]). In the latter case, an attacker who gains access to encrypting data
(ie, has chosen-plaintext strength) can manipulate the tweaks to essentially bypass
that synthetic extension of the domain space. 

FF3-1 uses 8 Feistel rounds, with a tweak schedule that works by summing
(via abelian summation) the left and right sides of the tweak in an alternating
fashion with the output of the previous round function. This is shown in [1]. 
The tweak size in FF3-1 is 64 bits, and is split into two halves consisting of
32 bits each. However, the last 4 bits of each subtweak (each half) are fixed to 0,
in order to mitigate the recent attack by Durak & Vaudenay [2].
Thus, the total number of available tweaks is 2^56. 

As FF3-1 splits tweaks in half and uses half a tweak in each round function,
randomly chosen tweaks should have high entropy within each half of the tweak.
For example, creating many encryptions with tweaks with the same right or left half 
will lead to more biased encryptions (where the distinction between the corresponding
encryptions rely solely on the randomness of the abelian summation operator).
In practice, using randomly chosen tweaks will be enough -- however, it is important
to avoid using an algorithm to generate tweaks that yields similarity between two
halves of tweaks [4]. 

Finally, encrypting the same plaintext with the same key and tweak is deterministic,
so two plaintexts that happen to coincide will lead to two ciphertexts
that coincide. Thus, no matching plaintexts for different objects should be
stored with the same tweaks. For example, if the ciphertexts corresponding to the last four digits
of phone numbers are stored, then there may be plaintext collisions, and these
collision values should not be encrypted with the same tweak [3, Appendix C].

## FF3-1 Best Practices:

From the problems that may arise from the previous section, we have a list
of recommendations for how to use tweaks in the FF3-1 paradigm.

* Encryption should be as restricted as possible via ACLs. 
* Tweaks are not user controlled, but are randomly chosen and treated as 
sensitive (if not secret). 
* Tweaks make use of the max length allowed for the bytestring,
and have high entropy (as uniformly variable as possible over the max tweak 
domain space and differing with each encryption). Tweaks should utilize the
full domain space.
* Care should be taken to ensure that the same tweak is not used to encrypt
two of the same values that correspond to different underlying entities.

## Further Resources: 

* 1: https://eprint.iacr.org/2020/1311.pdf
* 2: https://csrc.nist.gov/news/2017/recent-cryptanalysis-of-ff3 
* 3: https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-38g.pdf 
* 4: https://img.chainnews.com/paper/568b1f587c93f63832f083dd449107c2.pdf 
